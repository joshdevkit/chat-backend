
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `ConversationHide` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model ConversationHide
 * 
 */
export type ConversationHideModel = runtime.Types.Result.DefaultSelection<Prisma.$ConversationHidePayload>

export type AggregateConversationHide = {
  _count: ConversationHideCountAggregateOutputType | null
  _min: ConversationHideMinAggregateOutputType | null
  _max: ConversationHideMaxAggregateOutputType | null
}

export type ConversationHideMinAggregateOutputType = {
  id: string | null
  conversationId: string | null
  userId: string | null
  hiddenAt: Date | null
  visibleFrom: Date | null
}

export type ConversationHideMaxAggregateOutputType = {
  id: string | null
  conversationId: string | null
  userId: string | null
  hiddenAt: Date | null
  visibleFrom: Date | null
}

export type ConversationHideCountAggregateOutputType = {
  id: number
  conversationId: number
  userId: number
  hiddenAt: number
  visibleFrom: number
  _all: number
}


export type ConversationHideMinAggregateInputType = {
  id?: true
  conversationId?: true
  userId?: true
  hiddenAt?: true
  visibleFrom?: true
}

export type ConversationHideMaxAggregateInputType = {
  id?: true
  conversationId?: true
  userId?: true
  hiddenAt?: true
  visibleFrom?: true
}

export type ConversationHideCountAggregateInputType = {
  id?: true
  conversationId?: true
  userId?: true
  hiddenAt?: true
  visibleFrom?: true
  _all?: true
}

export type ConversationHideAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ConversationHide to aggregate.
   */
  where?: Prisma.ConversationHideWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ConversationHides to fetch.
   */
  orderBy?: Prisma.ConversationHideOrderByWithRelationInput | Prisma.ConversationHideOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.ConversationHideWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ConversationHides from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ConversationHides.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned ConversationHides
  **/
  _count?: true | ConversationHideCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: ConversationHideMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: ConversationHideMaxAggregateInputType
}

export type GetConversationHideAggregateType<T extends ConversationHideAggregateArgs> = {
      [P in keyof T & keyof AggregateConversationHide]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateConversationHide[P]>
    : Prisma.GetScalarType<T[P], AggregateConversationHide[P]>
}




export type ConversationHideGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ConversationHideWhereInput
  orderBy?: Prisma.ConversationHideOrderByWithAggregationInput | Prisma.ConversationHideOrderByWithAggregationInput[]
  by: Prisma.ConversationHideScalarFieldEnum[] | Prisma.ConversationHideScalarFieldEnum
  having?: Prisma.ConversationHideScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: ConversationHideCountAggregateInputType | true
  _min?: ConversationHideMinAggregateInputType
  _max?: ConversationHideMaxAggregateInputType
}

export type ConversationHideGroupByOutputType = {
  id: string
  conversationId: string
  userId: string
  hiddenAt: Date
  visibleFrom: Date | null
  _count: ConversationHideCountAggregateOutputType | null
  _min: ConversationHideMinAggregateOutputType | null
  _max: ConversationHideMaxAggregateOutputType | null
}

type GetConversationHideGroupByPayload<T extends ConversationHideGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ConversationHideGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof ConversationHideGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ConversationHideGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], ConversationHideGroupByOutputType[P]>
      }
    >
  >



export type ConversationHideWhereInput = {
  AND?: Prisma.ConversationHideWhereInput | Prisma.ConversationHideWhereInput[]
  OR?: Prisma.ConversationHideWhereInput[]
  NOT?: Prisma.ConversationHideWhereInput | Prisma.ConversationHideWhereInput[]
  id?: Prisma.StringFilter<"ConversationHide"> | string
  conversationId?: Prisma.StringFilter<"ConversationHide"> | string
  userId?: Prisma.StringFilter<"ConversationHide"> | string
  hiddenAt?: Prisma.DateTimeFilter<"ConversationHide"> | Date | string
  visibleFrom?: Prisma.DateTimeNullableFilter<"ConversationHide"> | Date | string | null
  conversation?: Prisma.XOR<Prisma.ConversationScalarRelationFilter, Prisma.ConversationWhereInput>
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}

export type ConversationHideOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  conversationId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  hiddenAt?: Prisma.SortOrder
  visibleFrom?: Prisma.SortOrderInput | Prisma.SortOrder
  conversation?: Prisma.ConversationOrderByWithRelationInput
  user?: Prisma.UserOrderByWithRelationInput
}

export type ConversationHideWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  conversationId_userId?: Prisma.ConversationHideConversationIdUserIdCompoundUniqueInput
  AND?: Prisma.ConversationHideWhereInput | Prisma.ConversationHideWhereInput[]
  OR?: Prisma.ConversationHideWhereInput[]
  NOT?: Prisma.ConversationHideWhereInput | Prisma.ConversationHideWhereInput[]
  conversationId?: Prisma.StringFilter<"ConversationHide"> | string
  userId?: Prisma.StringFilter<"ConversationHide"> | string
  hiddenAt?: Prisma.DateTimeFilter<"ConversationHide"> | Date | string
  visibleFrom?: Prisma.DateTimeNullableFilter<"ConversationHide"> | Date | string | null
  conversation?: Prisma.XOR<Prisma.ConversationScalarRelationFilter, Prisma.ConversationWhereInput>
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}, "id" | "conversationId_userId">

export type ConversationHideOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  conversationId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  hiddenAt?: Prisma.SortOrder
  visibleFrom?: Prisma.SortOrderInput | Prisma.SortOrder
  _count?: Prisma.ConversationHideCountOrderByAggregateInput
  _max?: Prisma.ConversationHideMaxOrderByAggregateInput
  _min?: Prisma.ConversationHideMinOrderByAggregateInput
}

export type ConversationHideScalarWhereWithAggregatesInput = {
  AND?: Prisma.ConversationHideScalarWhereWithAggregatesInput | Prisma.ConversationHideScalarWhereWithAggregatesInput[]
  OR?: Prisma.ConversationHideScalarWhereWithAggregatesInput[]
  NOT?: Prisma.ConversationHideScalarWhereWithAggregatesInput | Prisma.ConversationHideScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"ConversationHide"> | string
  conversationId?: Prisma.StringWithAggregatesFilter<"ConversationHide"> | string
  userId?: Prisma.StringWithAggregatesFilter<"ConversationHide"> | string
  hiddenAt?: Prisma.DateTimeWithAggregatesFilter<"ConversationHide"> | Date | string
  visibleFrom?: Prisma.DateTimeNullableWithAggregatesFilter<"ConversationHide"> | Date | string | null
}

export type ConversationHideCreateInput = {
  id?: string
  hiddenAt?: Date | string
  visibleFrom?: Date | string | null
  conversation: Prisma.ConversationCreateNestedOneWithoutHidesInput
  user: Prisma.UserCreateNestedOneWithoutConversationHidesInput
}

export type ConversationHideUncheckedCreateInput = {
  id?: string
  conversationId: string
  userId: string
  hiddenAt?: Date | string
  visibleFrom?: Date | string | null
}

export type ConversationHideUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  hiddenAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  visibleFrom?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  conversation?: Prisma.ConversationUpdateOneRequiredWithoutHidesNestedInput
  user?: Prisma.UserUpdateOneRequiredWithoutConversationHidesNestedInput
}

export type ConversationHideUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  conversationId?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  hiddenAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  visibleFrom?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type ConversationHideCreateManyInput = {
  id?: string
  conversationId: string
  userId: string
  hiddenAt?: Date | string
  visibleFrom?: Date | string | null
}

export type ConversationHideUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  hiddenAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  visibleFrom?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type ConversationHideUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  conversationId?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  hiddenAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  visibleFrom?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type ConversationHideListRelationFilter = {
  every?: Prisma.ConversationHideWhereInput
  some?: Prisma.ConversationHideWhereInput
  none?: Prisma.ConversationHideWhereInput
}

export type ConversationHideOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type ConversationHideConversationIdUserIdCompoundUniqueInput = {
  conversationId: string
  userId: string
}

export type ConversationHideCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  conversationId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  hiddenAt?: Prisma.SortOrder
  visibleFrom?: Prisma.SortOrder
}

export type ConversationHideMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  conversationId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  hiddenAt?: Prisma.SortOrder
  visibleFrom?: Prisma.SortOrder
}

export type ConversationHideMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  conversationId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  hiddenAt?: Prisma.SortOrder
  visibleFrom?: Prisma.SortOrder
}

export type ConversationHideCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.ConversationHideCreateWithoutUserInput, Prisma.ConversationHideUncheckedCreateWithoutUserInput> | Prisma.ConversationHideCreateWithoutUserInput[] | Prisma.ConversationHideUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.ConversationHideCreateOrConnectWithoutUserInput | Prisma.ConversationHideCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.ConversationHideCreateManyUserInputEnvelope
  connect?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
}

export type ConversationHideUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.ConversationHideCreateWithoutUserInput, Prisma.ConversationHideUncheckedCreateWithoutUserInput> | Prisma.ConversationHideCreateWithoutUserInput[] | Prisma.ConversationHideUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.ConversationHideCreateOrConnectWithoutUserInput | Prisma.ConversationHideCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.ConversationHideCreateManyUserInputEnvelope
  connect?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
}

export type ConversationHideUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.ConversationHideCreateWithoutUserInput, Prisma.ConversationHideUncheckedCreateWithoutUserInput> | Prisma.ConversationHideCreateWithoutUserInput[] | Prisma.ConversationHideUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.ConversationHideCreateOrConnectWithoutUserInput | Prisma.ConversationHideCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.ConversationHideUpsertWithWhereUniqueWithoutUserInput | Prisma.ConversationHideUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.ConversationHideCreateManyUserInputEnvelope
  set?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  disconnect?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  delete?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  connect?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  update?: Prisma.ConversationHideUpdateWithWhereUniqueWithoutUserInput | Prisma.ConversationHideUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.ConversationHideUpdateManyWithWhereWithoutUserInput | Prisma.ConversationHideUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.ConversationHideScalarWhereInput | Prisma.ConversationHideScalarWhereInput[]
}

export type ConversationHideUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.ConversationHideCreateWithoutUserInput, Prisma.ConversationHideUncheckedCreateWithoutUserInput> | Prisma.ConversationHideCreateWithoutUserInput[] | Prisma.ConversationHideUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.ConversationHideCreateOrConnectWithoutUserInput | Prisma.ConversationHideCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.ConversationHideUpsertWithWhereUniqueWithoutUserInput | Prisma.ConversationHideUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.ConversationHideCreateManyUserInputEnvelope
  set?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  disconnect?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  delete?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  connect?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  update?: Prisma.ConversationHideUpdateWithWhereUniqueWithoutUserInput | Prisma.ConversationHideUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.ConversationHideUpdateManyWithWhereWithoutUserInput | Prisma.ConversationHideUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.ConversationHideScalarWhereInput | Prisma.ConversationHideScalarWhereInput[]
}

export type ConversationHideCreateNestedManyWithoutConversationInput = {
  create?: Prisma.XOR<Prisma.ConversationHideCreateWithoutConversationInput, Prisma.ConversationHideUncheckedCreateWithoutConversationInput> | Prisma.ConversationHideCreateWithoutConversationInput[] | Prisma.ConversationHideUncheckedCreateWithoutConversationInput[]
  connectOrCreate?: Prisma.ConversationHideCreateOrConnectWithoutConversationInput | Prisma.ConversationHideCreateOrConnectWithoutConversationInput[]
  createMany?: Prisma.ConversationHideCreateManyConversationInputEnvelope
  connect?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
}

export type ConversationHideUncheckedCreateNestedManyWithoutConversationInput = {
  create?: Prisma.XOR<Prisma.ConversationHideCreateWithoutConversationInput, Prisma.ConversationHideUncheckedCreateWithoutConversationInput> | Prisma.ConversationHideCreateWithoutConversationInput[] | Prisma.ConversationHideUncheckedCreateWithoutConversationInput[]
  connectOrCreate?: Prisma.ConversationHideCreateOrConnectWithoutConversationInput | Prisma.ConversationHideCreateOrConnectWithoutConversationInput[]
  createMany?: Prisma.ConversationHideCreateManyConversationInputEnvelope
  connect?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
}

export type ConversationHideUpdateManyWithoutConversationNestedInput = {
  create?: Prisma.XOR<Prisma.ConversationHideCreateWithoutConversationInput, Prisma.ConversationHideUncheckedCreateWithoutConversationInput> | Prisma.ConversationHideCreateWithoutConversationInput[] | Prisma.ConversationHideUncheckedCreateWithoutConversationInput[]
  connectOrCreate?: Prisma.ConversationHideCreateOrConnectWithoutConversationInput | Prisma.ConversationHideCreateOrConnectWithoutConversationInput[]
  upsert?: Prisma.ConversationHideUpsertWithWhereUniqueWithoutConversationInput | Prisma.ConversationHideUpsertWithWhereUniqueWithoutConversationInput[]
  createMany?: Prisma.ConversationHideCreateManyConversationInputEnvelope
  set?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  disconnect?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  delete?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  connect?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  update?: Prisma.ConversationHideUpdateWithWhereUniqueWithoutConversationInput | Prisma.ConversationHideUpdateWithWhereUniqueWithoutConversationInput[]
  updateMany?: Prisma.ConversationHideUpdateManyWithWhereWithoutConversationInput | Prisma.ConversationHideUpdateManyWithWhereWithoutConversationInput[]
  deleteMany?: Prisma.ConversationHideScalarWhereInput | Prisma.ConversationHideScalarWhereInput[]
}

export type ConversationHideUncheckedUpdateManyWithoutConversationNestedInput = {
  create?: Prisma.XOR<Prisma.ConversationHideCreateWithoutConversationInput, Prisma.ConversationHideUncheckedCreateWithoutConversationInput> | Prisma.ConversationHideCreateWithoutConversationInput[] | Prisma.ConversationHideUncheckedCreateWithoutConversationInput[]
  connectOrCreate?: Prisma.ConversationHideCreateOrConnectWithoutConversationInput | Prisma.ConversationHideCreateOrConnectWithoutConversationInput[]
  upsert?: Prisma.ConversationHideUpsertWithWhereUniqueWithoutConversationInput | Prisma.ConversationHideUpsertWithWhereUniqueWithoutConversationInput[]
  createMany?: Prisma.ConversationHideCreateManyConversationInputEnvelope
  set?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  disconnect?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  delete?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  connect?: Prisma.ConversationHideWhereUniqueInput | Prisma.ConversationHideWhereUniqueInput[]
  update?: Prisma.ConversationHideUpdateWithWhereUniqueWithoutConversationInput | Prisma.ConversationHideUpdateWithWhereUniqueWithoutConversationInput[]
  updateMany?: Prisma.ConversationHideUpdateManyWithWhereWithoutConversationInput | Prisma.ConversationHideUpdateManyWithWhereWithoutConversationInput[]
  deleteMany?: Prisma.ConversationHideScalarWhereInput | Prisma.ConversationHideScalarWhereInput[]
}

export type ConversationHideCreateWithoutUserInput = {
  id?: string
  hiddenAt?: Date | string
  visibleFrom?: Date | string | null
  conversation: Prisma.ConversationCreateNestedOneWithoutHidesInput
}

export type ConversationHideUncheckedCreateWithoutUserInput = {
  id?: string
  conversationId: string
  hiddenAt?: Date | string
  visibleFrom?: Date | string | null
}

export type ConversationHideCreateOrConnectWithoutUserInput = {
  where: Prisma.ConversationHideWhereUniqueInput
  create: Prisma.XOR<Prisma.ConversationHideCreateWithoutUserInput, Prisma.ConversationHideUncheckedCreateWithoutUserInput>
}

export type ConversationHideCreateManyUserInputEnvelope = {
  data: Prisma.ConversationHideCreateManyUserInput | Prisma.ConversationHideCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type ConversationHideUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.ConversationHideWhereUniqueInput
  update: Prisma.XOR<Prisma.ConversationHideUpdateWithoutUserInput, Prisma.ConversationHideUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.ConversationHideCreateWithoutUserInput, Prisma.ConversationHideUncheckedCreateWithoutUserInput>
}

export type ConversationHideUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.ConversationHideWhereUniqueInput
  data: Prisma.XOR<Prisma.ConversationHideUpdateWithoutUserInput, Prisma.ConversationHideUncheckedUpdateWithoutUserInput>
}

export type ConversationHideUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.ConversationHideScalarWhereInput
  data: Prisma.XOR<Prisma.ConversationHideUpdateManyMutationInput, Prisma.ConversationHideUncheckedUpdateManyWithoutUserInput>
}

export type ConversationHideScalarWhereInput = {
  AND?: Prisma.ConversationHideScalarWhereInput | Prisma.ConversationHideScalarWhereInput[]
  OR?: Prisma.ConversationHideScalarWhereInput[]
  NOT?: Prisma.ConversationHideScalarWhereInput | Prisma.ConversationHideScalarWhereInput[]
  id?: Prisma.StringFilter<"ConversationHide"> | string
  conversationId?: Prisma.StringFilter<"ConversationHide"> | string
  userId?: Prisma.StringFilter<"ConversationHide"> | string
  hiddenAt?: Prisma.DateTimeFilter<"ConversationHide"> | Date | string
  visibleFrom?: Prisma.DateTimeNullableFilter<"ConversationHide"> | Date | string | null
}

export type ConversationHideCreateWithoutConversationInput = {
  id?: string
  hiddenAt?: Date | string
  visibleFrom?: Date | string | null
  user: Prisma.UserCreateNestedOneWithoutConversationHidesInput
}

export type ConversationHideUncheckedCreateWithoutConversationInput = {
  id?: string
  userId: string
  hiddenAt?: Date | string
  visibleFrom?: Date | string | null
}

export type ConversationHideCreateOrConnectWithoutConversationInput = {
  where: Prisma.ConversationHideWhereUniqueInput
  create: Prisma.XOR<Prisma.ConversationHideCreateWithoutConversationInput, Prisma.ConversationHideUncheckedCreateWithoutConversationInput>
}

export type ConversationHideCreateManyConversationInputEnvelope = {
  data: Prisma.ConversationHideCreateManyConversationInput | Prisma.ConversationHideCreateManyConversationInput[]
  skipDuplicates?: boolean
}

export type ConversationHideUpsertWithWhereUniqueWithoutConversationInput = {
  where: Prisma.ConversationHideWhereUniqueInput
  update: Prisma.XOR<Prisma.ConversationHideUpdateWithoutConversationInput, Prisma.ConversationHideUncheckedUpdateWithoutConversationInput>
  create: Prisma.XOR<Prisma.ConversationHideCreateWithoutConversationInput, Prisma.ConversationHideUncheckedCreateWithoutConversationInput>
}

export type ConversationHideUpdateWithWhereUniqueWithoutConversationInput = {
  where: Prisma.ConversationHideWhereUniqueInput
  data: Prisma.XOR<Prisma.ConversationHideUpdateWithoutConversationInput, Prisma.ConversationHideUncheckedUpdateWithoutConversationInput>
}

export type ConversationHideUpdateManyWithWhereWithoutConversationInput = {
  where: Prisma.ConversationHideScalarWhereInput
  data: Prisma.XOR<Prisma.ConversationHideUpdateManyMutationInput, Prisma.ConversationHideUncheckedUpdateManyWithoutConversationInput>
}

export type ConversationHideCreateManyUserInput = {
  id?: string
  conversationId: string
  hiddenAt?: Date | string
  visibleFrom?: Date | string | null
}

export type ConversationHideUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  hiddenAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  visibleFrom?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  conversation?: Prisma.ConversationUpdateOneRequiredWithoutHidesNestedInput
}

export type ConversationHideUncheckedUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  conversationId?: Prisma.StringFieldUpdateOperationsInput | string
  hiddenAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  visibleFrom?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type ConversationHideUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  conversationId?: Prisma.StringFieldUpdateOperationsInput | string
  hiddenAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  visibleFrom?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type ConversationHideCreateManyConversationInput = {
  id?: string
  userId: string
  hiddenAt?: Date | string
  visibleFrom?: Date | string | null
}

export type ConversationHideUpdateWithoutConversationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  hiddenAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  visibleFrom?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  user?: Prisma.UserUpdateOneRequiredWithoutConversationHidesNestedInput
}

export type ConversationHideUncheckedUpdateWithoutConversationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  hiddenAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  visibleFrom?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type ConversationHideUncheckedUpdateManyWithoutConversationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  hiddenAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  visibleFrom?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}



export type ConversationHideSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  conversationId?: boolean
  userId?: boolean
  hiddenAt?: boolean
  visibleFrom?: boolean
  conversation?: boolean | Prisma.ConversationDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["conversationHide"]>

export type ConversationHideSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  conversationId?: boolean
  userId?: boolean
  hiddenAt?: boolean
  visibleFrom?: boolean
  conversation?: boolean | Prisma.ConversationDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["conversationHide"]>

export type ConversationHideSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  conversationId?: boolean
  userId?: boolean
  hiddenAt?: boolean
  visibleFrom?: boolean
  conversation?: boolean | Prisma.ConversationDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["conversationHide"]>

export type ConversationHideSelectScalar = {
  id?: boolean
  conversationId?: boolean
  userId?: boolean
  hiddenAt?: boolean
  visibleFrom?: boolean
}

export type ConversationHideOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "conversationId" | "userId" | "hiddenAt" | "visibleFrom", ExtArgs["result"]["conversationHide"]>
export type ConversationHideInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  conversation?: boolean | Prisma.ConversationDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type ConversationHideIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  conversation?: boolean | Prisma.ConversationDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type ConversationHideIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  conversation?: boolean | Prisma.ConversationDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}

export type $ConversationHidePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "ConversationHide"
  objects: {
    conversation: Prisma.$ConversationPayload<ExtArgs>
    user: Prisma.$UserPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    conversationId: string
    userId: string
    hiddenAt: Date
    visibleFrom: Date | null
  }, ExtArgs["result"]["conversationHide"]>
  composites: {}
}

export type ConversationHideGetPayload<S extends boolean | null | undefined | ConversationHideDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$ConversationHidePayload, S>

export type ConversationHideCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<ConversationHideFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ConversationHideCountAggregateInputType | true
  }

export interface ConversationHideDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationHide'], meta: { name: 'ConversationHide' } }
  /**
   * Find zero or one ConversationHide that matches the filter.
   * @param {ConversationHideFindUniqueArgs} args - Arguments to find a ConversationHide
   * @example
   * // Get one ConversationHide
   * const conversationHide = await prisma.conversationHide.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ConversationHideFindUniqueArgs>(args: Prisma.SelectSubset<T, ConversationHideFindUniqueArgs<ExtArgs>>): Prisma.Prisma__ConversationHideClient<runtime.Types.Result.GetResult<Prisma.$ConversationHidePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one ConversationHide that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ConversationHideFindUniqueOrThrowArgs} args - Arguments to find a ConversationHide
   * @example
   * // Get one ConversationHide
   * const conversationHide = await prisma.conversationHide.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ConversationHideFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, ConversationHideFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__ConversationHideClient<runtime.Types.Result.GetResult<Prisma.$ConversationHidePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ConversationHide that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ConversationHideFindFirstArgs} args - Arguments to find a ConversationHide
   * @example
   * // Get one ConversationHide
   * const conversationHide = await prisma.conversationHide.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ConversationHideFindFirstArgs>(args?: Prisma.SelectSubset<T, ConversationHideFindFirstArgs<ExtArgs>>): Prisma.Prisma__ConversationHideClient<runtime.Types.Result.GetResult<Prisma.$ConversationHidePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ConversationHide that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ConversationHideFindFirstOrThrowArgs} args - Arguments to find a ConversationHide
   * @example
   * // Get one ConversationHide
   * const conversationHide = await prisma.conversationHide.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ConversationHideFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, ConversationHideFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__ConversationHideClient<runtime.Types.Result.GetResult<Prisma.$ConversationHidePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more ConversationHides that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ConversationHideFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ConversationHides
   * const conversationHides = await prisma.conversationHide.findMany()
   * 
   * // Get first 10 ConversationHides
   * const conversationHides = await prisma.conversationHide.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const conversationHideWithIdOnly = await prisma.conversationHide.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends ConversationHideFindManyArgs>(args?: Prisma.SelectSubset<T, ConversationHideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ConversationHidePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a ConversationHide.
   * @param {ConversationHideCreateArgs} args - Arguments to create a ConversationHide.
   * @example
   * // Create one ConversationHide
   * const ConversationHide = await prisma.conversationHide.create({
   *   data: {
   *     // ... data to create a ConversationHide
   *   }
   * })
   * 
   */
  create<T extends ConversationHideCreateArgs>(args: Prisma.SelectSubset<T, ConversationHideCreateArgs<ExtArgs>>): Prisma.Prisma__ConversationHideClient<runtime.Types.Result.GetResult<Prisma.$ConversationHidePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many ConversationHides.
   * @param {ConversationHideCreateManyArgs} args - Arguments to create many ConversationHides.
   * @example
   * // Create many ConversationHides
   * const conversationHide = await prisma.conversationHide.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends ConversationHideCreateManyArgs>(args?: Prisma.SelectSubset<T, ConversationHideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many ConversationHides and returns the data saved in the database.
   * @param {ConversationHideCreateManyAndReturnArgs} args - Arguments to create many ConversationHides.
   * @example
   * // Create many ConversationHides
   * const conversationHide = await prisma.conversationHide.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many ConversationHides and only return the `id`
   * const conversationHideWithIdOnly = await prisma.conversationHide.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends ConversationHideCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, ConversationHideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ConversationHidePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a ConversationHide.
   * @param {ConversationHideDeleteArgs} args - Arguments to delete one ConversationHide.
   * @example
   * // Delete one ConversationHide
   * const ConversationHide = await prisma.conversationHide.delete({
   *   where: {
   *     // ... filter to delete one ConversationHide
   *   }
   * })
   * 
   */
  delete<T extends ConversationHideDeleteArgs>(args: Prisma.SelectSubset<T, ConversationHideDeleteArgs<ExtArgs>>): Prisma.Prisma__ConversationHideClient<runtime.Types.Result.GetResult<Prisma.$ConversationHidePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one ConversationHide.
   * @param {ConversationHideUpdateArgs} args - Arguments to update one ConversationHide.
   * @example
   * // Update one ConversationHide
   * const conversationHide = await prisma.conversationHide.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends ConversationHideUpdateArgs>(args: Prisma.SelectSubset<T, ConversationHideUpdateArgs<ExtArgs>>): Prisma.Prisma__ConversationHideClient<runtime.Types.Result.GetResult<Prisma.$ConversationHidePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more ConversationHides.
   * @param {ConversationHideDeleteManyArgs} args - Arguments to filter ConversationHides to delete.
   * @example
   * // Delete a few ConversationHides
   * const { count } = await prisma.conversationHide.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends ConversationHideDeleteManyArgs>(args?: Prisma.SelectSubset<T, ConversationHideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ConversationHides.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ConversationHideUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ConversationHides
   * const conversationHide = await prisma.conversationHide.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends ConversationHideUpdateManyArgs>(args: Prisma.SelectSubset<T, ConversationHideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ConversationHides and returns the data updated in the database.
   * @param {ConversationHideUpdateManyAndReturnArgs} args - Arguments to update many ConversationHides.
   * @example
   * // Update many ConversationHides
   * const conversationHide = await prisma.conversationHide.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more ConversationHides and only return the `id`
   * const conversationHideWithIdOnly = await prisma.conversationHide.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends ConversationHideUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, ConversationHideUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ConversationHidePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one ConversationHide.
   * @param {ConversationHideUpsertArgs} args - Arguments to update or create a ConversationHide.
   * @example
   * // Update or create a ConversationHide
   * const conversationHide = await prisma.conversationHide.upsert({
   *   create: {
   *     // ... data to create a ConversationHide
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ConversationHide we want to update
   *   }
   * })
   */
  upsert<T extends ConversationHideUpsertArgs>(args: Prisma.SelectSubset<T, ConversationHideUpsertArgs<ExtArgs>>): Prisma.Prisma__ConversationHideClient<runtime.Types.Result.GetResult<Prisma.$ConversationHidePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of ConversationHides.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ConversationHideCountArgs} args - Arguments to filter ConversationHides to count.
   * @example
   * // Count the number of ConversationHides
   * const count = await prisma.conversationHide.count({
   *   where: {
   *     // ... the filter for the ConversationHides we want to count
   *   }
   * })
  **/
  count<T extends ConversationHideCountArgs>(
    args?: Prisma.Subset<T, ConversationHideCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], ConversationHideCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a ConversationHide.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ConversationHideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends ConversationHideAggregateArgs>(args: Prisma.Subset<T, ConversationHideAggregateArgs>): Prisma.PrismaPromise<GetConversationHideAggregateType<T>>

  /**
   * Group by ConversationHide.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ConversationHideGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends ConversationHideGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ConversationHideGroupByArgs['orderBy'] }
      : { orderBy?: ConversationHideGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, ConversationHideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationHideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the ConversationHide model
 */
readonly fields: ConversationHideFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ConversationHide.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ConversationHideClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  conversation<T extends Prisma.ConversationDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ConversationDefaultArgs<ExtArgs>>): Prisma.Prisma__ConversationClient<runtime.Types.Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the ConversationHide model
 */
export interface ConversationHideFieldRefs {
  readonly id: Prisma.FieldRef<"ConversationHide", 'String'>
  readonly conversationId: Prisma.FieldRef<"ConversationHide", 'String'>
  readonly userId: Prisma.FieldRef<"ConversationHide", 'String'>
  readonly hiddenAt: Prisma.FieldRef<"ConversationHide", 'DateTime'>
  readonly visibleFrom: Prisma.FieldRef<"ConversationHide", 'DateTime'>
}
    

// Custom InputTypes
/**
 * ConversationHide findUnique
 */
export type ConversationHideFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ConversationHide
   */
  select?: Prisma.ConversationHideSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ConversationHide
   */
  omit?: Prisma.ConversationHideOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConversationHideInclude<ExtArgs> | null
  /**
   * Filter, which ConversationHide to fetch.
   */
  where: Prisma.ConversationHideWhereUniqueInput
}

/**
 * ConversationHide findUniqueOrThrow
 */
export type ConversationHideFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ConversationHide
   */
  select?: Prisma.ConversationHideSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ConversationHide
   */
  omit?: Prisma.ConversationHideOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConversationHideInclude<ExtArgs> | null
  /**
   * Filter, which ConversationHide to fetch.
   */
  where: Prisma.ConversationHideWhereUniqueInput
}

/**
 * ConversationHide findFirst
 */
export type ConversationHideFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ConversationHide
   */
  select?: Prisma.ConversationHideSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ConversationHide
   */
  omit?: Prisma.ConversationHideOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConversationHideInclude<ExtArgs> | null
  /**
   * Filter, which ConversationHide to fetch.
   */
  where?: Prisma.ConversationHideWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ConversationHides to fetch.
   */
  orderBy?: Prisma.ConversationHideOrderByWithRelationInput | Prisma.ConversationHideOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ConversationHides.
   */
  cursor?: Prisma.ConversationHideWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ConversationHides from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ConversationHides.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ConversationHides.
   */
  distinct?: Prisma.ConversationHideScalarFieldEnum | Prisma.ConversationHideScalarFieldEnum[]
}

/**
 * ConversationHide findFirstOrThrow
 */
export type ConversationHideFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ConversationHide
   */
  select?: Prisma.ConversationHideSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ConversationHide
   */
  omit?: Prisma.ConversationHideOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConversationHideInclude<ExtArgs> | null
  /**
   * Filter, which ConversationHide to fetch.
   */
  where?: Prisma.ConversationHideWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ConversationHides to fetch.
   */
  orderBy?: Prisma.ConversationHideOrderByWithRelationInput | Prisma.ConversationHideOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ConversationHides.
   */
  cursor?: Prisma.ConversationHideWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ConversationHides from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ConversationHides.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ConversationHides.
   */
  distinct?: Prisma.ConversationHideScalarFieldEnum | Prisma.ConversationHideScalarFieldEnum[]
}

/**
 * ConversationHide findMany
 */
export type ConversationHideFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ConversationHide
   */
  select?: Prisma.ConversationHideSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ConversationHide
   */
  omit?: Prisma.ConversationHideOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConversationHideInclude<ExtArgs> | null
  /**
   * Filter, which ConversationHides to fetch.
   */
  where?: Prisma.ConversationHideWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ConversationHides to fetch.
   */
  orderBy?: Prisma.ConversationHideOrderByWithRelationInput | Prisma.ConversationHideOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing ConversationHides.
   */
  cursor?: Prisma.ConversationHideWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ConversationHides from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ConversationHides.
   */
  skip?: number
  distinct?: Prisma.ConversationHideScalarFieldEnum | Prisma.ConversationHideScalarFieldEnum[]
}

/**
 * ConversationHide create
 */
export type ConversationHideCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ConversationHide
   */
  select?: Prisma.ConversationHideSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ConversationHide
   */
  omit?: Prisma.ConversationHideOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConversationHideInclude<ExtArgs> | null
  /**
   * The data needed to create a ConversationHide.
   */
  data: Prisma.XOR<Prisma.ConversationHideCreateInput, Prisma.ConversationHideUncheckedCreateInput>
}

/**
 * ConversationHide createMany
 */
export type ConversationHideCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many ConversationHides.
   */
  data: Prisma.ConversationHideCreateManyInput | Prisma.ConversationHideCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * ConversationHide createManyAndReturn
 */
export type ConversationHideCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ConversationHide
   */
  select?: Prisma.ConversationHideSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ConversationHide
   */
  omit?: Prisma.ConversationHideOmit<ExtArgs> | null
  /**
   * The data used to create many ConversationHides.
   */
  data: Prisma.ConversationHideCreateManyInput | Prisma.ConversationHideCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConversationHideIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * ConversationHide update
 */
export type ConversationHideUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ConversationHide
   */
  select?: Prisma.ConversationHideSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ConversationHide
   */
  omit?: Prisma.ConversationHideOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConversationHideInclude<ExtArgs> | null
  /**
   * The data needed to update a ConversationHide.
   */
  data: Prisma.XOR<Prisma.ConversationHideUpdateInput, Prisma.ConversationHideUncheckedUpdateInput>
  /**
   * Choose, which ConversationHide to update.
   */
  where: Prisma.ConversationHideWhereUniqueInput
}

/**
 * ConversationHide updateMany
 */
export type ConversationHideUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update ConversationHides.
   */
  data: Prisma.XOR<Prisma.ConversationHideUpdateManyMutationInput, Prisma.ConversationHideUncheckedUpdateManyInput>
  /**
   * Filter which ConversationHides to update
   */
  where?: Prisma.ConversationHideWhereInput
  /**
   * Limit how many ConversationHides to update.
   */
  limit?: number
}

/**
 * ConversationHide updateManyAndReturn
 */
export type ConversationHideUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ConversationHide
   */
  select?: Prisma.ConversationHideSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ConversationHide
   */
  omit?: Prisma.ConversationHideOmit<ExtArgs> | null
  /**
   * The data used to update ConversationHides.
   */
  data: Prisma.XOR<Prisma.ConversationHideUpdateManyMutationInput, Prisma.ConversationHideUncheckedUpdateManyInput>
  /**
   * Filter which ConversationHides to update
   */
  where?: Prisma.ConversationHideWhereInput
  /**
   * Limit how many ConversationHides to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConversationHideIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * ConversationHide upsert
 */
export type ConversationHideUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ConversationHide
   */
  select?: Prisma.ConversationHideSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ConversationHide
   */
  omit?: Prisma.ConversationHideOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConversationHideInclude<ExtArgs> | null
  /**
   * The filter to search for the ConversationHide to update in case it exists.
   */
  where: Prisma.ConversationHideWhereUniqueInput
  /**
   * In case the ConversationHide found by the `where` argument doesn't exist, create a new ConversationHide with this data.
   */
  create: Prisma.XOR<Prisma.ConversationHideCreateInput, Prisma.ConversationHideUncheckedCreateInput>
  /**
   * In case the ConversationHide was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.ConversationHideUpdateInput, Prisma.ConversationHideUncheckedUpdateInput>
}

/**
 * ConversationHide delete
 */
export type ConversationHideDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ConversationHide
   */
  select?: Prisma.ConversationHideSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ConversationHide
   */
  omit?: Prisma.ConversationHideOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConversationHideInclude<ExtArgs> | null
  /**
   * Filter which ConversationHide to delete.
   */
  where: Prisma.ConversationHideWhereUniqueInput
}

/**
 * ConversationHide deleteMany
 */
export type ConversationHideDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ConversationHides to delete
   */
  where?: Prisma.ConversationHideWhereInput
  /**
   * Limit how many ConversationHides to delete.
   */
  limit?: number
}

/**
 * ConversationHide without action
 */
export type ConversationHideDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ConversationHide
   */
  select?: Prisma.ConversationHideSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ConversationHide
   */
  omit?: Prisma.ConversationHideOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConversationHideInclude<ExtArgs> | null
}
